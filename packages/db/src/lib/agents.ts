import * as crypto from 'crypto';

interface AgentConfig {
  [key: string]: any;
}

  /**
   * Encrypts a plain text string using AES-256-CBC, with a key derived from the password.
   * @param text - The plain text to encrypt.
   * @param password - The password used to derive the encryption key.
   * @returns A string containing the salt, IV, and encrypted data (all in hexadecimal format, separated by colons).
   */
  export function encrypt(text: string, password: string): string {
    // Generate a random 16-byte salt.
    const salt = crypto.randomBytes(16);
    // Derive a 32-byte key using the password and salt.
    const key = crypto.scryptSync(password, salt, 32);

    // Generate a random 16-byte initialization vector.
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);

    // Encrypt the text.
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    // Return the salt, iv, and encrypted text as a single string.
    // They are separated by colons.
    return `${salt.toString('hex')}:${iv.toString('hex')}:${encrypted}`;
  }

  /**
   * Decrypts an AES-256-CBC encrypted string that was generated by the `encrypt` function.
   * @param encrypted - The encrypted string (which contains the salt, IV, and ciphertext, separated by colons).
   * @param password - The password used to derive the decryption key.
   * @returns The decrypted plain text.
   */
  export function decrypt(encrypted: string, password: string): string {
      // The encrypted string is expected to be in the format: salt:iv:ciphertext
      const parts = encrypted.split(':');
      if (parts.length !== 3) {
      throw new Error('Invalid input format. Expected salt:iv:encryptedData');
      }

      // Extract the salt, IV, and ciphertext.
      const salt = Buffer.from(parts[0], 'hex');
      const iv = Buffer.from(parts[1], 'hex');
      const data = parts[2];

      // Derive the same key using the password and salt.
      const key = crypto.scryptSync(password, salt, 32);

      // Decrypt the ciphertext.
      const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv);
      let decrypted = decipher.update(data, 'hex', 'utf8');
      decrypted += decipher.final('utf8');

      return decrypted;
  }


export async function createAgent(
  organizationId: string,
  name: string,
  description: string,
  status: string,
  version: string,
  configuration: AgentConfig,
  metadata: AgentConfig
) {
  try {
    const now = new Date().toISOString();
    const result = await Bun.sql`
      INSERT INTO agents (
        organization_id, name, description, status, version, 
        configuration, metadata, created_at, updated_at
      )
      VALUES (
        ${organizationId}, ${name}, ${description}, ${status}, ${version}, 
        ${JSON.stringify(configuration)}::jsonb, ${JSON.stringify(metadata)}::jsonb,
        ${now}, ${now}
      )
      RETURNING *
    `.values();

    return result[0] ?? null;
  } catch (error) {
    console.error('Failed to create agent:', error);
    throw error;
  }
}

export async function getAgentById(id: string) {
  try {
    const agent = await Bun.sql`
      SELECT * FROM agents 
      WHERE id = ${id}
    `.values();

    const envVars = await Bun.sql`
      SELECT * FROM agent_environment_variables
      WHERE agent_id = ${id}
    `.values();

    const integrations = await Bun.sql`
      SELECT * FROM service_integrations
      WHERE agent_id = ${id}
    `.values();

    const deployments = await Bun.sql`
      SELECT * FROM deployment_history
      WHERE agent_id = ${id}
      ORDER BY created_at DESC
    `.values();

    const analytics = await Bun.sql`
      SELECT * FROM agent_analytics
      WHERE agent_id = ${id}
      ORDER BY timestamp DESC
    `.values();

    const logs = await Bun.sql`
      SELECT * FROM agent_logs
      WHERE agent_id = ${id}
      ORDER BY timestamp DESC
    `.values();

    return {
      ...agent[0],
      envVars,
      integrations,
      deployments,
      analytics,
      logs
    };
  } catch (error) {
    console.error('Failed to get agent:', error);
    throw error;
  }
}

export async function updateAgent(
  id: string,
  name?: string,
  description?: string,
  container_id?: string,
  status?: string,
  version?: string,
  configuration?: AgentConfig,
  metadata?: AgentConfig
) {
  try {
    const now = new Date().toISOString();
    const result = await Bun.sql`
      UPDATE agents 
      SET name = COALESCE(${name}, name),
          description = COALESCE(${description}, description),
          container_id = COALESCE(${container_id}, container_id),
          status = COALESCE(${status}, status),
          version = COALESCE(${version}, version),
          configuration = COALESCE(${JSON.stringify(configuration)}::jsonb, configuration),
          metadata = COALESCE(${JSON.stringify(metadata)}::jsonb, metadata),
          updated_at = ${now}
      WHERE id = ${id}
      RETURNING *
    `.values();

    return result[0] ?? null;
  } catch (error) {
    console.error('Failed to update agent:', error);
    throw error;
  }
}

export async function getAgentEnvVariables(id: string, encryptionKey: string) {
  try {
    const result = await Bun.sql`
      SELECT key_name, encrypted_value, salt, iv, is_secret 
      FROM agent_environment_variables
      WHERE agent_id = ${id}
    `.values();

    // Decrypt each value and return as key-value pairs
    const decryptedVars: Record<string, string> = {};
    for (const row of result) {
      const encryptedData = `${row[2].toString('hex')}:${row[3].toString('hex')}:${row[1].toString('hex')}`;
      try {
        decryptedVars[row[0]] = decrypt(encryptedData, encryptionKey);
      } catch (decryptError) {
        console.error(`Failed to decrypt value for ${row[0]}:`, decryptError);
        decryptedVars[row[0]] = '[DECRYPTION_ERROR]';
      }
    }

    return decryptedVars;
  } catch (error) {
    console.error('Failed to get agent environment variables:', error);
    throw error;
  }
}

export async function insertAgentEnvVariables(
  id: string,
  variables: Record<string, string>,
  encryptionKey: string
) {
  try {
    const now = new Date().toISOString();
    const values = [];
    const entries = Object.entries(variables);

    for (const [key, value] of entries) {
      // Encrypt the value
      const encrypted = encrypt(value, encryptionKey);
      const [salt, iv, encryptedValue] = encrypted.split(':');

      values.push({
        agent_id: id,
        key_name: key,
        encrypted_value: Buffer.from(encryptedValue, 'hex'),
        salt: Buffer.from(salt, 'hex'),
        iv: Buffer.from(iv, 'hex'),
        created_at: now,
        updated_at: now,
        is_secret: true
      });
    }
    // Insert all variables
    const result = await Promise.all(
      values.map(async (value) => {
        return await Bun.sql`
          INSERT INTO agent_environment_variables (
            agent_id, key_name, encrypted_value, salt, iv, 
            created_at, updated_at, is_secret
          )
          VALUES (${value.agent_id}, ${value.key_name}, ${value.encrypted_value}, ${value.salt}, ${value.iv},
                  ${value.created_at}, ${value.updated_at}, ${value.is_secret})
          RETURNING *
        `.values();
      })
    );

    return result;
  } catch (error) {
    console.error('Failed to insert agent environment variables:', error);
    throw error;
  }
}


export async function updateAgentEnvVariables(
  id: string,
  variables: Record<string, string>,
  encryptionKey: string
) {
  try {
    const now = new Date().toISOString();
    const updates = [];

    for (const [key, value] of Object.entries(variables)) {
      // Encrypt the value
      const encrypted = encrypt(value, encryptionKey);
      const [salt, iv, encryptedValue] = encrypted.split(':');

      // Update each variable individually to maintain the unique constraint
      const result = await Bun.sql`
        INSERT INTO agent_environment_variables (
          agent_id, key_name, encrypted_value, salt, iv, 
          created_at, updated_at, is_secret
        )
        VALUES (
          ${id}, ${key}, ${Buffer.from(encryptedValue, 'hex')}, 
          ${Buffer.from(salt, 'hex')}, ${Buffer.from(iv, 'hex')}, ${now}, ${now}, true
        )
        ON CONFLICT (agent_id, key_name) DO UPDATE
        SET encrypted_value = EXCLUDED.encrypted_value,
            iv = EXCLUDED.iv,
            salt = EXCLUDED.salt,
            updated_at = EXCLUDED.updated_at
        RETURNING *
      `.values();

      updates.push(result[0]);
    }

    return updates;
  } catch (error) {
    console.error('Failed to update agent environment variables:', error);
    throw error;
  }
}


export async function deleteAgent(id: string) {
  try {
    // Delete associated records first
    await Bun.sql`DELETE FROM agent_environment_variables WHERE agent_id = ${id}`;
    await Bun.sql`DELETE FROM service_integrations WHERE agent_id = ${id}`;
    await Bun.sql`DELETE FROM deployment_history WHERE agent_id = ${id}`;
    await Bun.sql`DELETE FROM agent_analytics WHERE agent_id = ${id}`;
    await Bun.sql`DELETE FROM agent_logs WHERE agent_id = ${id}`;
    await Bun.sql`DELETE FROM blockchain_integrations WHERE agent_id = ${id}`;

    // Finally delete the agent
    const result = await Bun.sql`
      DELETE FROM agents 
      WHERE id = ${id}
      RETURNING id
    `.values();

    return result[0]?.id ? true : false;
  } catch (error) {
    console.error('Failed to delete agent:', error);
    throw error;
  }
}

export async function getAgentsAndStatsByOrganizationId(organizationId: string) {
  try {
    const _agents = await Bun.sql`
      SELECT a.*, 
        (SELECT COUNT(*) FROM agent_environment_variables WHERE agent_id = a.id) as env_vars_count,
        (SELECT COUNT(*) FROM service_integrations WHERE agent_id = a.id) as integrations_count,
        (SELECT COUNT(*) FROM deployment_history WHERE agent_id = a.id) as deployments_count,
        (SELECT COUNT(*) FROM agent_analytics WHERE agent_id = a.id) as analytics_count,
        (SELECT COUNT(*) FROM agent_logs WHERE agent_id = a.id) as logs_count,
        (SELECT COUNT(*) FROM blockchain_integrations WHERE agent_id = a.id) as blockchain_integrations_count
      FROM agents a
      WHERE a.organization_id = ${organizationId}
      ORDER BY a.created_at DESC
    `.values();

    const agents = _agents.map((agent: any) => {
      return {
        id: agent[0],
        organization_id: agent[1],
        name: agent[2],
        description: agent[3],
        status: agent[4],
        version: agent[5],
        created_at: agent[6],
        updated_at: agent[7],
        last_active: agent[8],
        container_id: agent[9],
        deployment_count: agent[10],
        configuration: JSON.parse(agent[11]),
        metadata: JSON.parse(agent[12]),
        env_vars_count: 0,
        integrations_count: 0,
        deployments_count: 0,
        analytics_count: 0,
        logs_count: 0,
        blockchain_integrations_count: 0
      }
    })

    return agents;
  } catch (error) {
    console.error('Failed to get agents by organization ID:', error);
    throw error;
  }
}


export async function getAgentsByOrganizationId(organizationId: string) {
  try {
    const _agents = await Bun.sql`
      SELECT * FROM agents 
      WHERE organization_id = ${organizationId} 
      AND status = 'active'
      ORDER BY created_at DESC
    `.values();

    const agents = _agents.map((agent: any) => {
      return {
        id: agent[0],
        organization_id: agent[1],
        logo: '',
        name: agent[2],
        description: agent[3],
        status: agent[4],
        version: agent[5],
        created_at: agent[6],
        updated_at: agent[7],
        last_active: agent[8],
        container_id: agent[9],
        deployment_count: agent[10],
        configuration: JSON.parse(agent[11]),
        metadata: JSON.parse(agent[12]),
        plan: 'basic'
      }
    })

    return agents;
  } catch (error) {
    console.error('Failed to get agents by organization ID:', error);
    throw error;
  }
}